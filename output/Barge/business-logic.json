{
  "businessObject": "Barge",
  "baseClass": "BargeBase",
  "namespace": "BargeOps.Onshore.BusinessLogic",
  "description": "Core business entity representing a barge with comprehensive tracking of location, status, physical characteristics, and operational details",
  "properties": [
    {
      "name": "BargeID",
      "type": "Int32",
      "access": "ReadOnly",
      "isPrimaryKey": true,
      "isNullable": false,
      "description": "Unique identifier for the barge"
    },
    {
      "name": "BargeNum",
      "type": "String",
      "access": "ReadWrite",
      "maxLength": 50,
      "isRequired": true,
      "description": "Barge number - unique identifier visible to users"
    },
    {
      "name": "UscgNum",
      "type": "String",
      "access": "ReadWrite",
      "maxLength": 50,
      "description": "Coast Guard VIN (Vessel Identification Number)"
    },
    {
      "name": "IsActive",
      "type": "Boolean",
      "access": "ReadWrite",
      "isRequired": true,
      "defaultValue": true,
      "description": "Indicates if the barge is currently active"
    },
    {
      "name": "CustomerID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Operator/customer owning or operating the barge"
    },
    {
      "name": "OwnerID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Owner of the barge (may differ from operator)"
    },
    {
      "name": "HullType",
      "type": "Char",
      "access": "ReadWrite",
      "maxLength": 1,
      "description": "Type of hull (e.g., Box, Hopper)"
    },
    {
      "name": "ExternalLength",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "External length of the barge in feet"
    },
    {
      "name": "ExternalWidth",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "External width of the barge in feet"
    },
    {
      "name": "ExternalDepth",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "External depth of the barge in feet"
    },
    {
      "name": "Draft",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "Overall draft of the barge in feet"
    },
    {
      "name": "DraftPortBow",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "Draft measurement at port bow corner"
    },
    {
      "name": "DraftPortStern",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "Draft measurement at port stern corner"
    },
    {
      "name": "DraftStarboardBow",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "Draft measurement at starboard bow corner"
    },
    {
      "name": "DraftStarboardStern",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "Draft measurement at starboard stern corner"
    },
    {
      "name": "DraftCalculated",
      "type": "Decimal",
      "access": "ReadWrite",
      "description": "Calculated draft based on corner measurements"
    },
    {
      "name": "CoverType",
      "type": "String",
      "access": "ReadWrite",
      "description": "Type of cover on the barge (e.g., OT for Open Top)"
    },
    {
      "name": "CoverConfig",
      "type": "String",
      "access": "ReadWrite",
      "description": "Configuration of the cover (e.g., Open, Closed)"
    },
    {
      "name": "CoverSubTypeID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Sub-type classification for the cover"
    },
    {
      "name": "SizeCategory",
      "type": "String",
      "access": "ReadWrite",
      "description": "Size classification (Jumbo, Oversize, Undersize)"
    },
    {
      "name": "CommodityID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Current or last commodity carried by the barge"
    },
    {
      "name": "LocationID",
      "type": "Int32",
      "access": "ReadWrite (special)",
      "description": "Current location of the barge - uses special setter with datetime and tier/berth parameters"
    },
    {
      "name": "LocationDateTime",
      "type": "DateTime",
      "access": "ReadOnly (set via LocationID)",
      "description": "Date and time of the last position update"
    },
    {
      "name": "TierID",
      "type": "Int32",
      "access": "ReadOnly (set via LocationID)",
      "description": "Current tier where barge is located"
    },
    {
      "name": "TierX",
      "type": "Int16",
      "access": "ReadOnly (set via LocationID)",
      "description": "X-coordinate in the tier"
    },
    {
      "name": "TierY",
      "type": "Int16",
      "access": "ReadOnly (set via LocationID)",
      "description": "Y-coordinate in the tier"
    },
    {
      "name": "FacilityBerthID",
      "type": "Int32",
      "access": "ReadOnly (set via LocationID)",
      "description": "Current berth where barge is located"
    },
    {
      "name": "FacilityBerthX",
      "type": "Int16",
      "access": "ReadOnly (set via LocationID)",
      "description": "X-coordinate in the berth"
    },
    {
      "name": "FacilityBerthY",
      "type": "Int16",
      "access": "ReadOnly (set via LocationID)",
      "description": "Y-coordinate in the berth"
    },
    {
      "name": "LoadStatus",
      "type": "String",
      "access": "ReadWrite",
      "description": "Current load status of the barge"
    },
    {
      "name": "CleanStatus",
      "type": "String",
      "access": "ReadWrite",
      "description": "Cleanliness status of the barge"
    },
    {
      "name": "RepairStatus",
      "type": "String",
      "access": "ReadWrite",
      "description": "Repair status of the barge"
    },
    {
      "name": "DamageLevel",
      "type": "String",
      "access": "ReadWrite",
      "description": "Level or severity of damage"
    },
    {
      "name": "DamageNote",
      "type": "String",
      "access": "ReadWrite",
      "description": "Notes describing damage details"
    },
    {
      "name": "IsCargoDamaged",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if cargo is damaged"
    },
    {
      "name": "IsLeaker",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if the barge is leaking"
    },
    {
      "name": "IsDryDocked",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if the barge is in dry dock"
    },
    {
      "name": "IsRepairScheduled",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if repair is scheduled"
    },
    {
      "name": "IsDamaged",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if damage has been noted"
    },
    {
      "name": "HasInsufficientFreeboard",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if barge has insufficient freeboard"
    },
    {
      "name": "HasAnchorWire",
      "type": "Boolean",
      "access": "ReadWrite",
      "defaultValue": false,
      "description": "Indicates if barge has anchor wire"
    },
    {
      "name": "FreeboardRange",
      "type": "String",
      "access": "ReadWrite",
      "description": "Range of freeboard measurements"
    },
    {
      "name": "FleetID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Fleet to which the barge is currently assigned"
    },
    {
      "name": "FleetBoatID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Boat currently servicing the barge"
    },
    {
      "name": "FleetBoatActivityDateTime",
      "type": "DateTime",
      "access": "ReadWrite",
      "description": "Date and time of last fleet boat activity"
    },
    {
      "name": "EquipmentType",
      "type": "String",
      "access": "ReadWrite",
      "description": "Type of equipment (e.g., Fleet-owned, Customer-owned)"
    },
    {
      "name": "ColorPairID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Color pair identifier for visual identification"
    },
    {
      "name": "RakeDirection",
      "type": "String",
      "access": "ReadWrite",
      "description": "Direction of rake (Left, Right, Up, Down)"
    },
    {
      "name": "TowString",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Tow string identifier"
    },
    {
      "name": "TowCut",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Tow cut identifier"
    },
    {
      "name": "BargeSyncIdentifier",
      "type": "Guid",
      "access": "ReadWrite",
      "description": "Unique identifier for synchronization purposes"
    },
    {
      "name": "InServiceDate",
      "type": "Date",
      "access": "ReadWrite",
      "description": "Date the barge was put into service"
    },
    {
      "name": "OutOfServiceDate",
      "type": "Date",
      "access": "ReadWrite",
      "description": "Date the barge was taken out of service"
    },
    {
      "name": "HullNumber",
      "type": "String",
      "access": "ReadWrite",
      "description": "Hull number identifier"
    },
    {
      "name": "BargeSeriesID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Series to which the barge belongs"
    },
    {
      "name": "GlAccountNum",
      "type": "String",
      "access": "ReadWrite",
      "description": "General Ledger account number"
    },
    {
      "name": "BargeType",
      "type": "String",
      "access": "ReadWrite",
      "description": "Type classification of the barge"
    },
    {
      "name": "ConvFesBargeID",
      "type": "Int32",
      "access": "ReadWrite",
      "description": "Legacy conversion/FES system barge identifier"
    },
    {
      "name": "Status",
      "type": "String",
      "access": "ReadOnly",
      "isCalculated": true,
      "description": "Calculated status based on location and tickets"
    },
    {
      "name": "InspectionStatus",
      "type": "String",
      "access": "ReadOnly",
      "isCalculated": true,
      "description": "Calculated inspection status"
    }
  ],
  "businessRules": [
    {
      "ruleName": "BargeNumRequired",
      "property": "BargeNum",
      "condition": "String.IsNullOrEmpty(BargeNum)",
      "message": "Barge number is required",
      "severity": "Error",
      "context": "Always",
      "modernEquivalent": "RuleFor(x => x.BargeNum).NotEmpty().WithMessage(\"Barge number is required\")"
    },
    {
      "ruleName": "BargeNumMaxLength",
      "property": "BargeNum",
      "condition": "BargeNum.Length > MaxLength.BargeNum",
      "message": "Barge number exceeds maximum length",
      "severity": "Error",
      "context": "Always",
      "modernEquivalent": "RuleFor(x => x.BargeNum).MaximumLength(MaxLength.BargeNum)"
    },
    {
      "ruleName": "ExternalLengthReasonable",
      "property": "ExternalLength",
      "condition": "ExternalLength <> String.Empty AND (ExternalLength > 50000.0 OR ExternalLength < 0.0)",
      "message": "[value] is not a reasonable value for Length",
      "severity": "Error",
      "context": "When ExternalLength has a value",
      "modernEquivalent": "RuleFor(x => x.ExternalLength).InclusiveBetween(0, 50000).When(x => x.ExternalLength.HasValue)"
    },
    {
      "ruleName": "ExternalWidthReasonable",
      "property": "ExternalWidth",
      "condition": "ExternalWidth <> String.Empty AND (ExternalWidth > 20000.0 OR ExternalWidth < 0.0)",
      "message": "[value] is not a reasonable value for Width",
      "severity": "Error",
      "context": "When ExternalWidth has a value",
      "modernEquivalent": "RuleFor(x => x.ExternalWidth).InclusiveBetween(0, 20000).When(x => x.ExternalWidth.HasValue)"
    },
    {
      "ruleName": "ExternalDepthReasonable",
      "property": "ExternalDepth",
      "condition": "ExternalDepth <> String.Empty AND (ExternalDepth > 10000.0 OR ExternalDepth < 0.0)",
      "message": "[value] is not a reasonable value for Depth",
      "severity": "Error",
      "context": "When ExternalDepth has a value",
      "modernEquivalent": "RuleFor(x => x.ExternalDepth).InclusiveBetween(0, 10000).When(x => x.ExternalDepth.HasValue)"
    },
    {
      "ruleName": "DraftMaximumCorners",
      "property": "Draft",
      "condition": "Draft <> String.Empty AND (DraftPortBow > Draft OR DraftPortStern > Draft OR DraftStarboardBow > Draft OR DraftStarboardStern > Draft)",
      "message": "Overall draft must be >= the highest corner draft",
      "severity": "Error",
      "context": "When Draft and any corner draft have values",
      "modernEquivalent": "Custom validation ensuring Draft >= Max(DraftPortBow, DraftPortStern, DraftStarboardBow, DraftStarboardStern)"
    },
    {
      "ruleName": "DraftRange",
      "property": "Draft",
      "condition": "Draft <> String.Empty AND (Draft > 99.999 OR Draft < 0.0)",
      "message": "Draft must be between 0 and 99 ft 11 in",
      "severity": "Error",
      "context": "When Draft has a value",
      "modernEquivalent": "RuleFor(x => x.Draft).InclusiveBetween(0, 99.999).When(x => x.Draft.HasValue)"
    },
    {
      "ruleName": "DraftInchesRange",
      "property": "DraftInches",
      "condition": "DraftInches <> String.Empty AND (DraftInches < 0 OR DraftInches > 11)",
      "message": "Draft inches must be between 0 and 11",
      "severity": "Error",
      "context": "When DraftInches has a value",
      "modernEquivalent": "RuleFor(x => x.DraftInches).InclusiveBetween(0, 11).When(x => x.DraftInches.HasValue)"
    },
    {
      "ruleName": "DraftPortBowRange",
      "property": "DraftPortBow",
      "condition": "DraftPortBow <> String.Empty AND (DraftPortBow > 99.999 OR DraftPortBow < 0.0)",
      "message": "Port bow draft must be between 0 and 99 ft 11 in",
      "severity": "Error",
      "context": "When DraftPortBow has a value",
      "modernEquivalent": "RuleFor(x => x.DraftPortBow).InclusiveBetween(0, 99.999).When(x => x.DraftPortBow.HasValue)"
    },
    {
      "ruleName": "DraftStarboardBowRange",
      "property": "DraftStarboardBow",
      "condition": "DraftStarboardBow <> String.Empty AND (DraftStarboardBow > 99.999 OR DraftStarboardBow < 0.0)",
      "message": "Starboard bow draft must be between 0 and 99 ft 11 in",
      "severity": "Error",
      "context": "When DraftStarboardBow has a value",
      "modernEquivalent": "RuleFor(x => x.DraftStarboardBow).InclusiveBetween(0, 99.999).When(x => x.DraftStarboardBow.HasValue)"
    },
    {
      "ruleName": "DraftPortSternRange",
      "property": "DraftPortStern",
      "condition": "DraftPortStern <> String.Empty AND (DraftPortStern > 99.999 OR DraftPortStern < 0.0)",
      "message": "Port stern draft must be between 0 and 99 ft 11 in",
      "severity": "Error",
      "context": "When DraftPortStern has a value",
      "modernEquivalent": "RuleFor(x => x.DraftPortStern).InclusiveBetween(0, 99.999).When(x => x.DraftPortStern.HasValue)"
    },
    {
      "ruleName": "DraftStarboardSternRange",
      "property": "DraftStarboardStern",
      "condition": "DraftStarboardStern <> String.Empty AND (DraftStarboardStern > 99.999 OR DraftStarboardStern < 0.0)",
      "message": "Starboard stern draft must be between 0 and 99 ft 11 in",
      "severity": "Error",
      "context": "When DraftStarboardStern has a value",
      "modernEquivalent": "RuleFor(x => x.DraftStarboardStern).InclusiveBetween(0, 99.999).When(x => x.DraftStarboardStern.HasValue)"
    },
    {
      "ruleName": "DraftCalculatedRange",
      "property": "DraftCalculated",
      "condition": "DraftCalculated <> String.Empty AND (DraftCalculated > 99.999 OR DraftCalculated < 0.0)",
      "message": "Calculated draft must be between 0 and 99 ft 11 in",
      "severity": "Error",
      "context": "When DraftCalculated has a value",
      "modernEquivalent": "RuleFor(x => x.DraftCalculated).InclusiveBetween(0, 99.999).When(x => x.DraftCalculated.HasValue)"
    },
    {
      "ruleName": "CustomerRequiredNotFleetOwned",
      "property": "CustomerID",
      "condition": "NOT IsTerminalActive AND EquipmentType.ToLower() <> 'fleet-owned' AND CustomerID = String.Empty",
      "message": "Operator is required",
      "severity": "Error",
      "context": "When not Fleet-owned and not Terminal Mode",
      "modernEquivalent": "RuleFor(x => x.CustomerID).NotEmpty().When(x => !IsTerminalActive && x.EquipmentType?.ToLower() != \"fleet-owned\")"
    },
    {
      "ruleName": "SizeCategoryRequiredNotFleetOwned",
      "property": "SizeCategory",
      "condition": "NOT IsTerminalActive AND EquipmentType.ToLower() <> 'fleet-owned' AND SizeCategory = String.Empty",
      "message": "Size is required",
      "severity": "Error",
      "context": "When not Fleet-owned and not Terminal Mode",
      "modernEquivalent": "RuleFor(x => x.SizeCategory).NotEmpty().When(x => !IsTerminalActive && x.EquipmentType?.ToLower() != \"fleet-owned\")"
    },
    {
      "ruleName": "FleetIDRequiredFleetOwned",
      "property": "FleetID",
      "condition": "EquipmentType.ToLower() = 'fleet-owned' AND FleetID = String.Empty",
      "message": "Fleet is required",
      "severity": "Error",
      "context": "When Fleet-owned",
      "modernEquivalent": "RuleFor(x => x.FleetID).NotEmpty().When(x => x.EquipmentType?.ToLower() == \"fleet-owned\")"
    },
    {
      "ruleName": "FacilityBerthLocationMatch",
      "property": "FacilityBerthID",
      "condition": "(FacilityBerthID NOT Empty OR FacilityBerthX NOT Empty OR FacilityBerthY NOT Empty) AND LocationID <> FacilityBerthList.GetLocationID(FacilityBerthID)",
      "message": "Facility Berth ID, Facility Berth X, and Facility Berth Y must be blank when the barge location does not match the berth location",
      "severity": "Error",
      "context": "When berth information provided but doesn't match barge location",
      "modernEquivalent": "Custom validator ensuring berth location matches barge location"
    },
    {
      "ruleName": "DamageNoteRequiresDamaged",
      "property": "DamageNote",
      "condition": "NOT IsDamaged AND DamageNote NOT Empty",
      "message": "Damage note must be blank if Damage noted is not checked",
      "severity": "Error",
      "context": "When IsDamaged is false",
      "modernEquivalent": "RuleFor(x => x.DamageNote).Empty().When(x => !x.IsDamaged)"
    },
    {
      "ruleName": "FreeboardRangeRequiredWhenInsufficient",
      "property": "FreeboardRange",
      "condition": "(HasInsufficientFreeboard AND FreeboardRange Empty) OR (NOT HasInsufficientFreeboard AND FreeboardRange NOT Empty)",
      "message": "Freeboard range is required if Insufficient freeboard is checked",
      "severity": "Error",
      "context": "Conditional based on HasInsufficientFreeboard",
      "modernEquivalent": "RuleFor(x => x.FreeboardRange).NotEmpty().When(x => x.HasInsufficientFreeboard); RuleFor(x => x.FreeboardRange).Empty().When(x => !x.HasInsufficientFreeboard)"
    },
    {
      "ruleName": "OutOfServiceDateMustBeLater",
      "property": "OutOfServiceDate",
      "condition": "InServiceDate NOT Empty AND OutOfServiceDate NOT Empty AND InServiceDate >= OutOfServiceDate",
      "message": "The Out of service date must be later than the In service date",
      "severity": "Error",
      "context": "When both dates have values",
      "modernEquivalent": "RuleFor(x => x.OutOfServiceDate).GreaterThan(x => x.InServiceDate).When(x => x.InServiceDate.HasValue && x.OutOfServiceDate.HasValue)"
    },
    {
      "ruleName": "BargeChartersUniqueDateRanges",
      "property": "BargeCharters",
      "condition": "Complex: Any two charter date ranges overlap",
      "message": "The date ranges of two charters may not overlap",
      "severity": "Error",
      "context": "Collection-level validation",
      "modernEquivalent": "Custom validator for BargeCharters collection ensuring no date range overlaps"
    },
    {
      "ruleName": "CoverConfigRequiredForCompanyBarge",
      "property": "CoverConfig",
      "condition": "IsCompanyOperatedBargeCoverTypeSpecialLogic AND CoverType NOT Null AND CoverType <> 'OT' AND (CoverConfig Empty OR CoverConfig = 'Open')",
      "message": "Cover config is required and must have a value other than 'Open' when Cover type has a value and is not 'OT'",
      "severity": "Error",
      "context": "When EnableCoverTypeSpecialLogic is True and barge is company-operated and CoverType not OT",
      "modernEquivalent": "Complex conditional validation based on global settings and company operation status"
    },
    {
      "ruleName": "CoverConfigBlankForOTOrEmpty",
      "property": "CoverConfig",
      "condition": "IsCompanyOperatedBargeCoverTypeSpecialLogic AND (CoverType Empty OR CoverType = 'OT') AND CoverConfig NOT Empty",
      "message": "Cover config must be blank",
      "severity": "Error",
      "context": "When EnableCoverTypeSpecialLogic is True and barge is company-operated and CoverType is OT or empty",
      "modernEquivalent": "RuleFor(x => x.CoverConfig).Empty().When(x => IsCompanyOperated && (string.IsNullOrEmpty(x.CoverType) || x.CoverType == \"OT\"))"
    },
    {
      "ruleName": "CoverTypeRequiredForCommodity",
      "property": "CoverType",
      "condition": "(CoverType Empty OR CoverType = 'OT') AND IsRequiredCoverForCommodity()",
      "message": "The selected Commodity requires a cover, therefore a Cover type other than 'OT' is required",
      "severity": "Error",
      "context": "When commodity requires cover and barge is company-operated",
      "modernEquivalent": "RuleFor(x => x.CoverType).NotEmpty().Must(x => x != \"OT\").When(x => IsRequiredCoverForCommodity(x))"
    },
    {
      "ruleName": "CoverSubTypeRequiredForCommodity",
      "property": "CoverSubTypeID",
      "condition": "(CoverSubTypeID Empty OR CoverSubTypeID <= 0) AND IsRequiredCoverForCommodity()",
      "message": "The selected Commodity requires a cover, therefore Sub type is required",
      "severity": "Error",
      "context": "When commodity requires cover and barge is company-operated",
      "modernEquivalent": "RuleFor(x => x.CoverSubTypeID).GreaterThan(0).When(x => IsRequiredCoverForCommodity(x))"
    },
    {
      "ruleName": "CoverSubTypeBlankForOTOrEmpty",
      "property": "CoverSubTypeID",
      "condition": "CoverSubTypeID > 0 AND (CoverType Empty OR CoverType = 'OT')",
      "message": "Sub type must be blank when Cover type is 'OT' or has no value",
      "severity": "Error",
      "context": "When CoverType is OT or empty",
      "modernEquivalent": "RuleFor(x => x.CoverSubTypeID).Empty().When(x => string.IsNullOrEmpty(x.CoverType) || x.CoverType == \"OT\")"
    },
    {
      "ruleName": "CoverTypeRequired",
      "property": "CoverType",
      "condition": "CoverType Empty AND GlobalSettingList.RequireBargeCoverType",
      "message": "Cover type is required",
      "severity": "Error",
      "context": "When RequireBargeCoverType global setting is True",
      "modernEquivalent": "RuleFor(x => x.CoverType).NotEmpty().When(x => GlobalSettings.RequireBargeCoverType)"
    }
  ],
  "methods": {
    "factory": [
      {
        "name": "NewBarge",
        "signature": "Public Shared Function NewBarge() As Barge",
        "returnType": "Barge",
        "parameters": [],
        "description": "Creates a new Barge instance with default values"
      },
      {
        "name": "NewBargeAsChild",
        "signature": "Friend Shared Function NewBargeAsChild() As Barge",
        "returnType": "Barge",
        "parameters": [],
        "visibility": "Friend",
        "description": "Creates a new Barge as a child object"
      },
      {
        "name": "GetBarge",
        "signature": "Public Shared Function GetBarge(ByVal ID As Int32) As Barge",
        "returnType": "Barge",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32",
            "description": "BargeID to retrieve"
          }
        ],
        "description": "Loads an existing barge by ID"
      },
      {
        "name": "GetBargeChild",
        "signature": "Friend Shared Function GetBargeChild(ByVal ID As Int32) As Barge",
        "returnType": "Barge",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32",
            "description": "BargeID to retrieve"
          }
        ],
        "visibility": "Friend",
        "description": "Loads an existing barge as child object by ID"
      },
      {
        "name": "GetBargeChild",
        "signature": "Friend Shared Function GetBargeChild(ByVal dr As SafeDataReader) As Barge",
        "returnType": "Barge",
        "parameters": [
          {
            "name": "dr",
            "type": "SafeDataReader",
            "description": "Data reader with barge data"
          }
        ],
        "visibility": "Friend",
        "description": "Loads an existing barge as child object from data reader"
      }
    ],
    "crud": [
      {
        "name": "Save",
        "signature": "Inherited from BusinessLogicBase",
        "returnType": "Barge",
        "description": "Saves the barge to the database (insert or update)"
      },
      {
        "name": "SaveNoRefresh",
        "signature": "Inherited from BusinessLogicBase",
        "returnType": "void",
        "description": "Saves the barge without refreshing from database"
      },
      {
        "name": "DeleteBarge",
        "signature": "Public Shared Sub DeleteBarge(ByVal ID As Int32)",
        "returnType": "void",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32",
            "description": "BargeID to delete"
          }
        ],
        "description": "Deletes a barge by ID"
      }
    ],
    "businessLogic": [
      {
        "name": "GetOpenTicketID",
        "signature": "Public Function GetOpenTicketID() As Int32",
        "returnType": "Int32",
        "description": "Returns the TicketID of the current open ticket for this barge in the selected fleet. Returns 0 if no open ticket, negative if multiple open tickets"
      },
      {
        "name": "GetOpenTicketID",
        "signature": "Public Shared Function GetOpenTicketID(ByVal myBargeID As Int32, ByVal myFleetID As Int32) As Int32",
        "returnType": "Int32",
        "parameters": [
          {
            "name": "myBargeID",
            "type": "Int32"
          },
          {
            "name": "myFleetID",
            "type": "Int32"
          }
        ],
        "description": "Static version to get open ticket ID for specific barge and fleet"
      },
      {
        "name": "GetBargeID",
        "signature": "Public Shared Function GetBargeID(ByVal bargeNum As String) As Int32",
        "returnType": "Int32",
        "parameters": [
          {
            "name": "bargeNum",
            "type": "String"
          }
        ],
        "description": "Looks up BargeID by barge number"
      },
      {
        "name": "GetBargeNum",
        "signature": "Public Shared Function GetBargeNum(ByVal bargeNum As String) As String",
        "returnType": "String",
        "parameters": [
          {
            "name": "bargeNum",
            "type": "String",
            "description": "Barge number from external source (may have different format)"
          }
        ],
        "description": "Looks up the BargeOps-formatted BargeNum based on passed in bargeNum that may be from another source"
      },
      {
        "name": "GetBargeIDBySyncIdentifier",
        "signature": "Public Shared Function GetBargeIDBySyncIdentifier(ByVal BargeSyncIdentifier As Guid) As Integer",
        "returnType": "Integer",
        "parameters": [
          {
            "name": "BargeSyncIdentifier",
            "type": "Guid"
          }
        ],
        "description": "Returns the BargeID for the passed BargeSyncIdentifier"
      },
      {
        "name": "GetBargeSyncIdentifierByID",
        "signature": "Public Shared Function GetBargeSyncIdentifierByID(ByVal ID As Int32) As Guid",
        "returnType": "Guid",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32"
          }
        ],
        "description": "Returns the BargeSyncIdentifier for the passed BargeID"
      },
      {
        "name": "GetBargeNumBySyncIdentifier",
        "signature": "Public Shared Function GetBargeNumBySyncIdentifier(ByVal BargeSyncIdentifier As Guid) As String",
        "returnType": "String",
        "parameters": [
          {
            "name": "BargeSyncIdentifier",
            "type": "Guid"
          }
        ],
        "description": "Returns the BargeNum for the passed BargeSyncIdentifier"
      },
      {
        "name": "CloseTicketAndSave",
        "signature": "Public Shared Function CloseTicketAndSave(...) As RulesCollection",
        "returnType": "RulesCollection",
        "description": "Closes and saves a ticket and its associated barge. Returns Nothing if successful, BrokenRulesCollection if validation fails"
      },
      {
        "name": "VoidTicketAndSave",
        "signature": "Public Shared Function VoidTicketAndSave(...) As Barge",
        "returnType": "Barge",
        "description": "Voids and saves a ticket and its associated barge"
      },
      {
        "name": "ApiBargeDamageRepairUpdate",
        "signature": "Friend Shared Function ApiBargeDamageRepairUpdate(...) As String",
        "returnType": "String",
        "visibility": "Friend",
        "description": "API method to update barge damage and repair status. Returns empty string if successful, error message if failed"
      },
      {
        "name": "UpdateStatus",
        "signature": "Private Sub UpdateStatus()",
        "returnType": "void",
        "visibility": "Private",
        "description": "Updates the calculated Status property based on current location and selected fleet"
      },
      {
        "name": "SetInitialSizeCategory",
        "signature": "Private Sub SetInitialSizeCategory()",
        "returnType": "void",
        "visibility": "Private",
        "description": "Sets SizeCategory based on ExternalLength and ExternalWidth: Jumbo (195-200L, 35W), Oversize (>200L or >35W), else Undersize"
      },
      {
        "name": "MaxDraft",
        "signature": "Private Function MaxDraft() As String",
        "returnType": "String",
        "visibility": "Private",
        "description": "Returns the maximum value among all draft measurements (corner drafts and overall draft)"
      }
    ],
    "initialization": [
      {
        "name": "Initialize",
        "signature": "Public Overrides Sub Initialize()",
        "description": "Initializes all properties with default values and sets up display names for business rules"
      }
    ]
  },
  "relationships": [
    {
      "property": "Ticket",
      "relatedEntity": "Ticket",
      "type": "OneToOne (special)",
      "cascadeDelete": false,
      "deferredLoading": true,
      "description": "The current ticket associated with the barge. Access via BargeEventTicket property instead of base Ticket property"
    },
    {
      "property": "BargeEventTicket",
      "relatedEntity": "Ticket",
      "type": "OneToOne (dynamic)",
      "cascadeDelete": false,
      "deferredLoading": true,
      "description": "Gets the ticket based on BargeEventTicketID or the current open ticket"
    },
    {
      "property": "Alert",
      "relatedEntity": "Alert",
      "type": "OneToOne",
      "cascadeDelete": false,
      "deferredLoading": true,
      "description": "Alert associated with the barge"
    },
    {
      "property": "BargeCharters",
      "relatedEntity": "BargeCharter",
      "type": "OneToMany",
      "cascadeDelete": true,
      "deferredLoading": true,
      "description": "Collection of charters for this barge. Date ranges must not overlap"
    },
    {
      "property": "BargeSeries",
      "relatedEntity": "BargeSeries",
      "type": "ManyToOne",
      "foreignKey": "BargeSeriesID",
      "description": "The series to which this barge belongs. When set, auto-populates OwnerID, CustomerID, HullType, CoverType, and dimensions"
    },
    {
      "property": "Customer",
      "relatedEntity": "Customer",
      "type": "ManyToOne",
      "foreignKey": "CustomerID",
      "description": "The operator of the barge"
    },
    {
      "property": "Owner",
      "relatedEntity": "Customer",
      "type": "ManyToOne",
      "foreignKey": "OwnerID",
      "description": "The owner of the barge (may differ from operator)"
    },
    {
      "property": "Fleet",
      "relatedEntity": "Fleet",
      "type": "ManyToOne",
      "foreignKey": "FleetID",
      "description": "The fleet to which the barge is assigned"
    },
    {
      "property": "FleetBoat",
      "relatedEntity": "Boat",
      "type": "ManyToOne",
      "foreignKey": "FleetBoatID",
      "description": "The boat currently servicing the barge"
    },
    {
      "property": "Location",
      "relatedEntity": "Location",
      "type": "ManyToOne",
      "foreignKey": "LocationID",
      "description": "Current location of the barge"
    },
    {
      "property": "Tier",
      "relatedEntity": "Tier",
      "type": "ManyToOne",
      "foreignKey": "TierID",
      "description": "Current tier placement"
    },
    {
      "property": "FacilityBerth",
      "relatedEntity": "FacilityBerth",
      "type": "ManyToOne",
      "foreignKey": "FacilityBerthID",
      "description": "Current berth placement. Must be at same location as barge"
    },
    {
      "property": "Commodity",
      "relatedEntity": "Commodity",
      "type": "ManyToOne",
      "foreignKey": "CommodityID",
      "description": "Current or last commodity carried"
    },
    {
      "property": "ColorPair",
      "relatedEntity": "ColorPair",
      "type": "ManyToOne",
      "foreignKey": "ColorPairID",
      "description": "Color pair for visual identification"
    }
  ],
  "initialization": {
    "method": "Initialize",
    "defaults": [
      {
        "property": "IsActive",
        "value": "true"
      },
      {
        "property": "HasAnchorWire",
        "value": "false"
      },
      {
        "property": "BargeSyncIdentifier",
        "value": "Guid.NewGuid()"
      }
    ],
    "autoPopulateOnSeriesChange": [
      "OwnerID",
      "CustomerID",
      "HullType",
      "CoverType",
      "ExternalDepth",
      "ExternalLength",
      "ExternalWidth"
    ],
    "autoCalculateOnDimensionChange": [
      "SizeCategory"
    ]
  },
  "specialBehaviors": [
    {
      "name": "LocationUpdateWithDateTime",
      "description": "LocationID property has special setter that requires datetime, tier coordinates, and berth coordinates. Only updates if new datetime >= current datetime. Automatically clears tier/berth if they don't match new location."
    },
    {
      "name": "DraftFeetInchesConversion",
      "description": "Draft property is exposed as both decimal (feet) and as separate DraftFeet/DraftInches properties. Changes to either format automatically update the other."
    },
    {
      "name": "StatusCalculation",
      "description": "Status property is calculated based on location and fleet using stored procedure GetBargeStatus"
    },
    {
      "name": "FleetBoatActivityTimestamp",
      "description": "Setting FleetBoatID automatically updates FleetBoatActivityDateTime to current time"
    },
    {
      "name": "ClearStatusOnTicketClose",
      "description": "When ticket is closed, status fields (CoverConfig, LoadStatus, CommodityID, CleanStatus, RepairStatus, DamageLevel, DamageNote, flags) are cleared if no other fleet has an open ticket, unless Freight or Towing license is active for company barges"
    },
    {
      "name": "ClearDraftsOnTicketClose",
      "description": "When ticket is closed/voided, all draft fields are cleared if EnableClearBargeDraftsOnTicketClose global setting is True"
    },
    {
      "name": "AutoSizeCategoryLogic",
      "description": "When ExternalLength or ExternalWidth changes, SizeCategory is auto-set if EnableBargeSizeCategoryDefaultLogic is True: Jumbo (195-200L, 35W), Oversize (>200L or >35W), else Undersize"
    },
    {
      "name": "DamageLevelClearance",
      "description": "When DamageLevel is cleared, IsDamaged is set to False and DamageNote is cleared automatically"
    }
  ],
  "storedProcedures": {
    "select": "BargeSelect",
    "selectAll": "BargesSelect",
    "insert": "BargeInsert",
    "update": "BargeUpdate",
    "delete": "BargeDelete",
    "custom": [
      "GetOpenTicket",
      "GetBargeID",
      "GetBargeNum",
      "GetBargeStatus",
      "GetBargeIDBySyncIdentifier",
      "GetBargeSyncIdentifierByID",
      "GetBargeNumBySyncIdentifier"
    ]
  },
  "notes": [
    "This is a complex business object with extensive validation and business logic",
    "Location updates require datetime tracking and coordinate validation",
    "Multiple draft formats (decimal and feet/inches) must stay synchronized",
    "Ticket relationship is special - use BargeEventTicket not base Ticket property",
    "Cover type/config validation has complex conditional logic based on global settings",
    "Status fields have clearing logic tied to ticket lifecycle",
    "Company-operated barge detection affects multiple business rules",
    "Charter date ranges must not overlap (collection-level validation)",
    "BargeSeries auto-populates multiple fields when selected",
    "Size category can be auto-calculated based on dimensions"
  ]
}
