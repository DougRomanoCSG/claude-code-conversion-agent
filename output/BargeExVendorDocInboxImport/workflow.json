{
  "formName": "frmBargeExVendorDocInboxImport",
  "formType": "BatchImport",
  "formPurpose": "Import selected BargeEx vendor documents to create barge events and parts & service bills",
  "primaryWorkflows": [
    {
      "name": "ImportVendorDocuments",
      "description": "User imports selected vendor documents from BargeEx inbox",
      "steps": [
        {
          "step": 1,
          "action": "FormInitialization",
          "trigger": "Form Load",
          "details": "Form receives vendor document list from search form via Initialize method",
          "dataReceived": [
            "SubSystem",
            "SelectedFleetID",
            "VendorDocInboxList (DataTable with all rows, not just selected)"
          ]
        },
        {
          "step": 2,
          "action": "ValidateCanStart",
          "control": "btnStart",
          "enabledCondition": "VendorDocInboxList has rows where IsSelected = 1",
          "initialState": "Disabled until selection validated"
        },
        {
          "step": 3,
          "action": "ClickStart",
          "button": "btnStart",
          "result": "Begin processing selected rows"
        },
        {
          "step": 4,
          "action": "ProcessBatch",
          "sequence": [
            "Disable Start button permanently",
            "Change Cancel button to 'Cancel' from 'Close'",
            "Get selected rows sorted by VendorName, BargeNum, OriginalControlNumber, RevisionNumber",
            "Initialize progress bar with max = selected row count",
            "Loop through each selected row",
            "Determine DocType (BargeStatus or BoatStatus)",
            "Process row and update counters",
            "Update IDs for revision rows",
            "Check for user cancellation after each row",
            "Log summary when complete"
          ]
        },
        {
          "step": 5,
          "action": "ProcessComplete",
          "result": "Cancel button text changes to 'Close', user can review log and close form"
        }
      ]
    },
    {
      "name": "CancelImport",
      "description": "User cancels import in progress or closes form after completion",
      "steps": [
        {
          "step": 1,
          "action": "ClickCancel",
          "button": "btnCancel",
          "logic": "If button text = 'Close' then close form, else set _UserCanceledRun = True"
        },
        {
          "step": 2,
          "action": "ProcessCancellation",
          "result": "Import loop exits at next iteration, summary logged with partial counts"
        }
      ]
    }
  ],
  "formStates": [
    {
      "state": "Initial",
      "description": "Form just loaded, waiting for user to start",
      "txtLogState": "Empty",
      "progressBarState": "Zero",
      "btnStartState": "Enabled if selected rows exist, disabled otherwise",
      "btnCancelText": "Close",
      "canStartImport": true
    },
    {
      "state": "Processing",
      "description": "Import running, processing selected documents",
      "txtLogState": "Showing processing messages and results",
      "progressBarState": "Incrementing with each row processed",
      "btnStartState": "Disabled (permanently)",
      "btnCancelText": "Cancel",
      "canStartImport": false
    },
    {
      "state": "Completed",
      "description": "Import finished (successfully or via cancellation)",
      "txtLogState": "Shows complete log with summary",
      "progressBarState": "Final value",
      "btnStartState": "Disabled (permanently)",
      "btnCancelText": "Close",
      "canStartImport": false
    }
  ],
  "statePersistence": {
    "sessionVariables": [
      {
        "name": "_SubSystem",
        "type": "SubSystem",
        "scope": "Form lifetime",
        "purpose": "Identifies subsystem from calling search form"
      },
      {
        "name": "_SelectedFleetID",
        "type": "Int32",
        "scope": "Form lifetime",
        "purpose": "Fleet context for import operations"
      },
      {
        "name": "_VendorDocInboxList",
        "type": "DataTable",
        "scope": "Form lifetime",
        "purpose": "All vendor documents from search (both selected and unselected)",
        "updates": "IDs updated in-memory as revisions are processed"
      },
      {
        "name": "_UserCanceledRun",
        "type": "Boolean",
        "scope": "Form lifetime",
        "purpose": "Tracks user cancellation request",
        "defaultValue": false
      },
      {
        "name": "_ImportSuccessCount",
        "type": "Int32",
        "scope": "Form lifetime",
        "purpose": "Count of successfully imported records",
        "defaultValue": 0,
        "exposedAs": "Public ReadOnly Property ImportSuccessCount"
      },
      {
        "name": "_ImportErrorCount",
        "type": "Int32",
        "scope": "Form lifetime",
        "purpose": "Count of failed imports",
        "defaultValue": 0
      }
    ],
    "formSettings": [
      {
        "setting": "WindowPosition",
        "savedOn": "FormClosed",
        "restoredOn": "Load",
        "method": "MyAppSettingHelper.SaveForm/RestoreForm"
      },
      {
        "setting": "WindowSize",
        "savedOn": "FormClosed",
        "restoredOn": "Load",
        "method": "MyAppSettingHelper.SaveForm/RestoreForm"
      }
    ]
  },
  "eventHandlerChains": [
    {
      "triggerEvent": "Form Load",
      "eventHandler": "frmDetailEdit_Load",
      "chain": [
        {
          "step": 1,
          "method": "MyAppSettingHelper.RestoreForm",
          "purpose": "Restore form size and position"
        },
        {
          "step": 2,
          "method": "FormatControls",
          "purpose": "Initialize control states"
        }
      ]
    },
    {
      "triggerEvent": "btnStart Click",
      "eventHandler": "btnStart_Click",
      "chain": [
        {
          "step": 1,
          "method": "SetState(btnStart, ControlState.Disabled)",
          "purpose": "Prevent multiple runs"
        },
        {
          "step": 2,
          "action": "btnCancel.Text = 'Cancel'",
          "purpose": "Allow user to cancel processing"
        },
        {
          "step": 3,
          "method": "ProcessAll",
          "purpose": "Process all selected vendor documents",
          "subChain": [
            {
              "step": "3a",
              "method": "ProcessRow",
              "loopFor": "Each selected row",
              "calls": [
                "ProcessBargeStatus OR ProcessBoatStatus OR ProcessUnsupported"
              ]
            },
            {
              "step": "3b",
              "method": "UpdateIDs",
              "purpose": "Update revision rows with new IDs"
            },
            {
              "step": "3c",
              "method": "CancelRun",
              "purpose": "Check for user cancellation"
            }
          ]
        },
        {
          "step": 4,
          "action": "btnCancel.Text = 'Close'",
          "purpose": "Allow user to close form",
          "executedIn": "Finally block"
        }
      ]
    },
    {
      "triggerEvent": "btnCancel Click",
      "eventHandler": "btnCancel_Click",
      "chain": [
        {
          "step": 1,
          "condition": "btnCancel.Text = 'Close'",
          "action": "Me.Close()",
          "purpose": "Close form after import complete"
        },
        {
          "step": 2,
          "condition": "btnCancel.Text = 'Cancel'",
          "action": "_UserCanceledRun = True",
          "purpose": "Signal cancellation to import loop"
        }
      ]
    },
    {
      "triggerEvent": "Form Closed",
      "eventHandler": "frmBargeExVendorDocInboxImport_FormClosed",
      "chain": [
        {
          "step": 1,
          "method": "MyAppSettingHelper.SaveForm",
          "purpose": "Save form size and position"
        }
      ]
    }
  ],
  "businessLogicWorkflow": {
    "bargeStatusProcessing": {
      "description": "Import BargeStatus documents as Barge Events",
      "steps": [
        {
          "step": 1,
          "method": "ProcessBargeStatus",
          "determine": "isUpdate based on ControlNumber vs OriginalControlNumber and OriginalTicketEventID"
        },
        {
          "step": 2,
          "method": "GetBargeEvent",
          "logic": [
            "If Additional Clean (PrimaryControlNumber exists): Find original Clean event",
            "If Update: Find existing TicketEvent by OriginalControlNumber",
            "If New: Create new BargeEvent on open ticket or new ticket"
          ]
        },
        {
          "step": 3,
          "validations": [
            "CheckForVoid - Cannot import to/update voided tickets or events",
            "CheckForFinalBillAdjustments - Cannot adjust vendor bills in Final Bill status"
          ]
        },
        {
          "step": 4,
          "method": "SetProperties",
          "properties": [
            "StartDateTime",
            "CompleteDateTime",
            "CleanType/AdditionalCleanType/CoverHandlingType/PumpType",
            "Location fields (FromLocationID, ToLocationID, FleetBoatID)",
            "LoadStatus",
            "Division = OutsideVendor",
            "VendorID",
            "InvoiceNote = 'Vendor estimate via BargeEx: {amount}' if EstimatedCost exists",
            "MarkedForClose = False",
            "BargeExVendorControlNumber = OriginalControlNumber"
          ]
        },
        {
          "step": 5,
          "method": "SubmitRefreshClick",
          "action": "ApplyEdit + Save"
        },
        {
          "step": 6,
          "onSuccess": "Delete BargeExVendorDocumentInbox record via MultiDelete",
          "returnIDs": [
            "tcktEventID",
            "tcktID",
            "openTicketID (if event added to open ticket)",
            "brgID"
          ]
        }
      ]
    },
    "boatStatusProcessing": {
      "description": "Import BoatStatus documents as Parts & Service Bill Items",
      "steps": [
        {
          "step": 1,
          "method": "ProcessBoatStatus",
          "determine": "isUpdate based on ControlNumber vs OriginalControlNumber and OriginalPartsServiceBillItemID"
        },
        {
          "step": 2,
          "method": "GetPartsAndServiceBill",
          "logic": [
            "If Update: Find existing PartsServiceBillItem by OriginalControlNumber",
            "If New: Search for existing P&S Bill in ReadyForReview status for same customer/vendor/division",
            "If found: Use existing bill (latest by CreateDateTime)",
            "If not found: Create new PartsServiceBill",
            "Create new PartsServiceBillItem and add to bill"
          ]
        },
        {
          "step": 3,
          "method": "SetProperties",
          "billProperties": [
            "FleetID (new bills only)",
            "CustomerID = PsbillCustomerID (new bills only)",
            "Division = OutsideVendor (new bills only)",
            "VendorID (new bills only)"
          ],
          "itemProperties": [
            "PartsServiceCodeID = ASPartsServiceCodeID",
            "StartDateTime",
            "CompleteDateTime",
            "FleetBoatID = ServicingBoatID",
            "FacilityID = LocationID",
            "BoatID = AssistedBoatID",
            "River",
            "Mile",
            "InvoiceNote = 'Vendor estimate via BargeEx: {amount}' if EstimatedCost exists",
            "RateType = Flat (new items with estimated cost)",
            "BargeExVendorControlNumber = OriginalControlNumber (new items only)"
          ]
        },
        {
          "step": 4,
          "method": "SubmitRefreshClick",
          "action": "ApplyEdit + Save"
        },
        {
          "step": 5,
          "onSuccess": "Delete BargeExVendorDocumentInbox record via MultiDelete",
          "returnIDs": [
            "partsServiceBillItemID"
          ]
        }
      ]
    },
    "revisionHandling": {
      "description": "Handle revision documents that update original transactions",
      "keyLogic": [
        "Revisions have different ControlNumber than OriginalControlNumber",
        "Import is UPDATE only if OriginalTicketEventID or OriginalPartsServiceBillItemID has value",
        "Can import revisions even if original not imported yet (creates new instead of update)",
        "UpdateIDs method updates in-memory DataTable for unprocessed revision rows",
        "Updates OriginalTicketEventID, OriginalTicketID, or OriginalPartsServiceBillItemID columns",
        "Also updates TicketID column for other BargeStatus events of same barge when ticket opened"
      ]
    },
    "sortOrder": {
      "applied": "VendorName ASC, BargeNum ASC, OriginalControlNumber ASC, RevisionNumber ASC",
      "purpose": "Process original transactions before revisions for same control number"
    },
    "duplicateHandling": {
      "condition": "Lists.GlobalSettingList.DiscardDuplicateBargeExVendorDocuments = True",
      "eventType": "Fleeting events only",
      "logic": "If new Fleeting event, search for existing Fleeting event for same barge, vendor, location, and start date with blank BargeExVendorControlNumber",
      "onDuplicate": "Skip import, log message, delete inbox record (return Nothing)"
    }
  },
  "dataAccessPatterns": {
    "directAccessCalls": [
      {
        "storedProc": "BargeExVendorTicketEventSearch",
        "purpose": "Find existing TicketEvent by BargeExVendorControlNumber",
        "parameters": [
          "@FleetID",
          "@BargeID",
          "@VendorID",
          "@BargeExVendorControlNumber"
        ],
        "outputs": [
          "@TicketEventID",
          "@TicketID"
        ],
        "usage": "Called by FindTicketEvent method"
      },
      {
        "storedProc": "BargeExVendorPSBillItemSearch",
        "purpose": "Find existing PartsServiceBillItem by BargeExVendorControlNumber",
        "parameters": [
          "@FleetID",
          "@VendorID",
          "@BargeExVendorControlNumber"
        ],
        "outputs": [
          "@PartsServiceBillItemID",
          "@PartsServiceBillID"
        ],
        "usage": "Called by FindPartsServiceBillItem method"
      },
      {
        "storedProc": "BargeExVendorFleetingEventSearch",
        "purpose": "Find duplicate Fleeting event (BargeExVendorControlNumber is blank)",
        "parameters": [
          "@FleetID",
          "@BargeID",
          "@VendorID",
          "@FromLocationID",
          "@StartDateTime"
        ],
        "returns": "TicketEventID or -1",
        "usage": "Called by FindFleetingEvent method"
      },
      {
        "method": "BargeExVendorDocumentInbox.MultiDelete",
        "purpose": "Immediately delete inbox record after successful import",
        "parameter": "BargeExVendorDocumentInboxID"
      }
    ],
    "businessObjectCalls": [
      {
        "object": "BargeEvent",
        "methods": [
          "BargeEvent.GetBargeEvent(fleetID, bargeID, ticketID, ticketEventID) - Load existing",
          "BargeEvent.NewBargeEvent(eventType, eventStage, fleetID, bargeNum, createNewTicket, allowNewTicket, allowMatchingEvent) - Create new on new ticket",
          "BargeEvent.NewBargeEvent(eventType, eventStage, fleetID, bargeID, ticketID, forceNew, allowMatchingEvent) - Create new on existing ticket"
        ]
      },
      {
        "object": "PartsServiceBill",
        "methods": [
          "PartsServiceBill.GetPartsServiceBill(partsServiceBillID) - Load existing",
          "PartsServiceBill.NewPartsServiceBill() - Create new"
        ]
      },
      {
        "object": "PartsServiceBillItems",
        "methods": [
          "PartsServiceBillItems.NewPartsServiceBillItem() - Create new item",
          "PartsServiceBillItems.GetItemByID(partsServiceBillItemID) - Get existing item"
        ]
      },
      {
        "object": "TicketEvent",
        "methods": [
          "TicketEvent.GetOrderBargeTicketEventID(fleetID, bargeID, eventTypeName, fromLocID, toLocID, emptyString, startDateTime) - Find Shift with matching O/D pair"
        ]
      }
    ],
    "listSearchCalls": [
      {
        "list": "Lists.PartsServiceBillSearch.GetList",
        "purpose": "Find existing P&S Bills in ReadyForReview status for customer/vendor/division",
        "filters": [
          "FleetID = _SelectedFleetID",
          "BillableStatus = ReadyForReview",
          "IncludeVoided = False",
          "Adjustments = 'Exclude adjustments'",
          "CustomerID = row.PsbillCustomerID",
          "Division = OutsideVendor",
          "VendorID = row.VendorID"
        ],
        "sorting": "BillCreateDateTime DESC (to get latest)"
      }
    ]
  },
  "navigationPatterns": [
    {
      "from": "frmBargeExVendorDocInboxSearch",
      "to": "frmBargeExVendorDocInboxImport",
      "trigger": "Import button on search form",
      "dataPassedViaInitialize": [
        "SubSystem",
        "SelectedFleetID",
        "VendorDocInboxList (DataTable)"
      ],
      "modalDialog": true
    },
    {
      "from": "frmBargeExVendorDocInboxImport",
      "to": "frmBargeExVendorDocInboxSearch",
      "trigger": "Form Close",
      "returnData": "ImportSuccessCount property (readonly)",
      "purpose": "Calling form uses ImportSuccessCount > 0 to determine if it should refresh list"
    }
  ],
  "userExperience": {
    "defaultFocus": "btnStart (if enabled)",
    "keyboardShortcuts": [
      "Alt+S: Start import",
      "Alt+C: Cancel/Close"
    ],
    "progressFeedback": [
      "Progress bar shows current row / total selected rows",
      "Text log shows real-time processing messages",
      "Success/error counts displayed in summary"
    ],
    "errorHandling": [
      "Business rule violations logged to text window (not shown as dialog)",
      "Processing continues for remaining rows after errors",
      "Summary shows total success and error counts"
    ],
    "formBehavior": {
      "startButton": "Disabled permanently after first click - cannot re-run without closing form",
      "cancelButton": "Dynamic text ('Cancel' during processing, 'Close' before/after)",
      "txtLog": "ReadOnly, AlwaysInEditMode, scrollable",
      "minimumSize": "755x496",
      "showInTaskbar": false,
      "startPosition": "CenterParent"
    },
    "cancellationBehavior": {
      "during": "Sets flag, loop exits at next iteration, partial results logged",
      "timing": "RestoreFocus + 250ms delay + DoEvents to ensure Cancel click registers",
      "logged": "*** Import run CANCELED ***"
    }
  },
  "securityAuthorization": {
    "buttonTypes": [
      {
        "button": "btnStart",
        "type": "ButtonType.Action",
        "purpose": "Security checks for import action"
      },
      {
        "button": "btnCancel",
        "type": "ButtonType.Cancel",
        "purpose": "Always allowed"
      }
    ]
  },
  "errorScenarios": [
    {
      "scenario": "Barge doesn't exist in database",
      "brokenRule": "NoBarge",
      "message": "Transaction could not be imported because barge does not exist in the database."
    },
    {
      "scenario": "Vendor doesn't exist for SenderTradingPartnerNumber",
      "brokenRule": "NoVendor",
      "message": "Transaction could not be imported because no vendor exists in the database associated with this Sender Trading Partner Number [xxx]."
    },
    {
      "scenario": "Invalid event type",
      "brokenRule": "InvalidEvent",
      "message": "Transaction could not be imported because of invalid event type: '{EventTypeName}'."
    },
    {
      "scenario": "Cannot determine event stage",
      "brokenRule": "InvalidStage",
      "message": "Transaction could not be imported because the stage of the event could not be determined based on the type of event."
    },
    {
      "scenario": "Original transaction for Additional Clean not found",
      "brokenRule": "NoOriginal",
      "message": "Update transaction could not be imported for the Additional Clean type because no original Clean event could not be found for the primary control number [xxx]."
    },
    {
      "scenario": "Update transaction but no original event found",
      "brokenRule": "NoOriginal",
      "message": "Update transaction could not be imported because no barge event could be found for the original control number [xxx]."
    },
    {
      "scenario": "Update transaction but no original P&S Bill Item found",
      "brokenRule": "NoOriginal",
      "message": "Update transaction could not be imported because no Parts & Service Bill Item could be found for the original control number [xxx]."
    },
    {
      "scenario": "Ticket is voided (new event)",
      "brokenRule": "IsVoided",
      "message": "Skipping import - cannot add barge event to Ticket that has been voided."
    },
    {
      "scenario": "Ticket is voided (update event)",
      "brokenRule": "IsVoided",
      "message": "Skipping import - cannot update barge event on Ticket that has been voided."
    },
    {
      "scenario": "Ticket Event is voided",
      "brokenRule": "IsVoided",
      "message": "Skipping import - cannot update barge event that has been voided."
    },
    {
      "scenario": "Vendor bill in Final Bill status would be adjusted",
      "brokenRule": "AdjustmentForFinalBill",
      "message": "Skipping import - this vendor event is in Final Bill status and cannot be adjusted."
    },
    {
      "scenario": "Unsupported document type",
      "brokenRule": "NotSupported",
      "message": "Processing '{SubDocType}' for {VendorName}: Unsupported document type - cannot process this row."
    },
    {
      "scenario": "Duplicate Fleeting event found",
      "handling": "Skip import, log message, delete inbox record",
      "message": "Transaction skipped because it is a duplicate Fleeting event."
    }
  ],
  "updateVsNewLogic": {
    "bargeStatus": {
      "isUpdate": "(OriginalControlNumber != ControlNumber) AND OriginalTicketEventID has value",
      "isNew": "Otherwise",
      "propertySetBehavior": {
        "new": "Set property if newValue is not empty",
        "update": "Set property if newValue is not empty AND differs from currentValue"
      }
    },
    "boatStatus": {
      "isUpdate": "(OriginalControlNumber != ControlNumber) AND OriginalPartsServiceBillItemID has value",
      "isNew": "Otherwise",
      "propertySetBehavior": {
        "new": "Set property if newValue is not empty",
        "update": "Set property if newValue is not empty AND differs from currentValue"
      }
    }
  },
  "specialEventHandling": {
    "additionalClean": {
      "identifier": "PrimaryControlNumber field has value",
      "logic": "Find original Clean event by PrimaryControlNumber, update with AdditionalCleanType",
      "requiresOriginal": true
    },
    "shift": {
      "logic": "Search for existing Shift with same O/D pair (fromLocID, toLocID) and event type",
      "onMatch": "Update existing Shift",
      "onNoMatch": "Force creation of new Shift (forceNew = True)"
    },
    "fleeting": {
      "duplicateCheck": "If GlobalSetting enabled, search for existing Fleeting with blank BargeExVendorControlNumber",
      "onDuplicate": "Skip import"
    }
  }
}
