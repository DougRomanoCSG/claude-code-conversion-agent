{
  "businessObject": "RiverArea",
  "baseClass": "RiverAreaBase",
  "namespace": "BargeOps.BusinessObjects",
  "properties": [
    {
      "name": "RiverAreaID",
      "type": "Int32",
      "access": "ReadOnly",
      "isPrimaryKey": true,
      "isNullable": false,
      "description": "Unique identifier for the river area"
    },
    {
      "name": "Name",
      "type": "String",
      "access": "ReadWrite",
      "maxLength": 50,
      "isRequired": true,
      "isNullable": false,
      "description": "Name of the river area"
    },
    {
      "name": "IsActive",
      "type": "Boolean",
      "access": "ReadWrite",
      "isNullable": false,
      "defaultValue": true,
      "description": "Indicates if the river area is active"
    },
    {
      "name": "IsPriceZone",
      "type": "Boolean",
      "access": "ReadWrite",
      "isNullable": false,
      "defaultValue": false,
      "description": "Indicates if this area is designated as a pricing zone",
      "displayName": "Pricing zone"
    },
    {
      "name": "IsPortalArea",
      "type": "Boolean",
      "access": "ReadWrite",
      "isNullable": false,
      "defaultValue": false,
      "description": "Indicates if this area is designated as a portal area",
      "displayName": "Portal area"
    },
    {
      "name": "IsHighWaterArea",
      "type": "Boolean",
      "access": "ReadWrite",
      "isNullable": false,
      "defaultValue": false,
      "description": "Indicates if this area is designated as a high water area",
      "displayName": "High water area"
    },
    {
      "name": "CustomerID",
      "type": "String",
      "access": "ReadWrite",
      "isNullable": true,
      "description": "Customer associated with high water area - stored as string but represents Int32",
      "displayName": "High water customer"
    },
    {
      "name": "IsFuelTaxArea",
      "type": "Boolean",
      "access": "ReadWrite",
      "isNullable": false,
      "defaultValue": false,
      "description": "Indicates if this area is designated as a fuel tax area"
    },
    {
      "name": "IsLiquidRateArea",
      "type": "Boolean",
      "access": "ReadWrite",
      "isNullable": false,
      "defaultValue": false,
      "description": "Indicates if this area is designated as a liquid rate area"
    },
    {
      "name": "RiverAreaSegments",
      "type": "RiverAreaSegments",
      "access": "ReadOnly",
      "isCollection": true,
      "isChildCollection": true,
      "description": "Collection of river segments that define this river area"
    }
  ],
  "businessRules": [
    {
      "ruleName": "NameRequired",
      "property": "Name",
      "condition": "String.IsNullOrEmpty(Name)",
      "message": "Name is required",
      "severity": "Error",
      "context": "Always",
      "modernEquivalent": {
        "type": "DataAnnotation",
        "code": "[Required(ErrorMessage = \"Name is required\")]"
      }
    },
    {
      "ruleName": "NameMaxLength",
      "property": "Name",
      "condition": "Name.Length > 50",
      "message": "Name cannot exceed maximum length of 50.",
      "severity": "Error",
      "context": "Always",
      "modernEquivalent": {
        "type": "DataAnnotation",
        "code": "[StringLength(50, ErrorMessage = \"Name cannot exceed maximum length of 50.\")]"
      }
    },
    {
      "ruleName": "MutuallyExclusiveAreaTypes",
      "property": "IsPriceZone, IsPortalArea, IsHighWaterArea",
      "condition": "(IsPriceZone && IsPortalArea) || (IsPortalArea && IsHighWaterArea) || (IsPriceZone && IsHighWaterArea)",
      "message": "Only one of these may be checked: Pricing zone, Portal area, or High water area.",
      "severity": "Error",
      "context": "When any of IsPriceZone, IsPortalArea, or IsHighWaterArea changes",
      "modernEquivalent": {
        "type": "FluentValidation",
        "code": "RuleFor(x => x).Must(x => !(x.IsPriceZone && x.IsPortalArea) && !(x.IsPortalArea && x.IsHighWaterArea) && !(x.IsPriceZone && x.IsHighWaterArea)).WithMessage(\"Only one of these may be checked: Pricing zone, Portal area, or High water area.\")"
      }
    },
    {
      "ruleName": "CustomerIDRequiresHighWaterArea",
      "property": "CustomerID",
      "condition": "!IsHighWaterArea && !String.IsNullOrEmpty(CustomerID)",
      "message": "High water customer must be blank if High water area is not checked.",
      "severity": "Error",
      "context": "When CustomerID or IsHighWaterArea changes",
      "note": "The form automatically clears this field when user clicks Submit if High Water Area is not checked",
      "modernEquivalent": {
        "type": "FluentValidation",
        "code": "RuleFor(x => x.CustomerID).Empty().When(x => !x.IsHighWaterArea).WithMessage(\"High water customer must be blank if High water area is not checked.\")"
      }
    },
    {
      "ruleName": "OverlappingPricingZones",
      "property": "RiverAreaSegments",
      "condition": "IsPriceZone && River segments overlap with another pricing zone's segments",
      "message": "Another pricing zone has river segments that overlap this zone. The other zone(s) are {overlapping zone names}.",
      "severity": "Error",
      "context": "Only when IsPriceZone is true, checked on IsValid",
      "implementation": "CheckOverlappingPricingZones method compares Start Mile and End Mile of each river segment against any other pricing zone with matching river segments to determine overlap",
      "modernEquivalent": {
        "type": "FluentValidation",
        "code": "Custom validator to check for overlapping river segments when IsPriceZone is true"
      }
    }
  ],
  "childEntityRules": {
    "RiverAreaSegment": [
      {
        "ruleName": "RiverRequired",
        "property": "River",
        "condition": "String.IsNullOrEmpty(River)",
        "message": "River is required",
        "severity": "Error",
        "context": "Always"
      },
      {
        "ruleName": "RiverMaxLength",
        "property": "River",
        "condition": "River.Length > 3",
        "message": "River cannot exceed maximum length of 3.",
        "severity": "Error",
        "context": "Always"
      },
      {
        "ruleName": "StartMileRequired",
        "property": "StartMile",
        "condition": "String.IsNullOrEmpty(StartMile)",
        "message": "Start mile is required",
        "severity": "Error",
        "context": "Always"
      },
      {
        "ruleName": "EndMileRequired",
        "property": "EndMile",
        "condition": "String.IsNullOrEmpty(EndMile)",
        "message": "End mile is required",
        "severity": "Error",
        "context": "Always"
      },
      {
        "ruleName": "StartMileBetweenRiverRange",
        "property": "StartMile",
        "condition": "StartMile < River.MinMile || StartMile > River.MaxMile",
        "message": "Mile {StartMile} must be within the river's mile range of {MinMile} to {MaxMile}.",
        "severity": "Error",
        "context": "When River is selected",
        "implementation": "Looks up min/max mile from RiverList.GetRiver method"
      },
      {
        "ruleName": "EndMileBetweenRiverRange",
        "property": "EndMile",
        "condition": "EndMile < River.MinMile || EndMile > River.MaxMile",
        "message": "Mile {EndMile} must be within the river's mile range of {MinMile} to {MaxMile}.",
        "severity": "Error",
        "context": "When River is selected",
        "implementation": "Looks up min/max mile from RiverList.GetRiver method"
      },
      {
        "ruleName": "StartMileNotGreaterEndMile",
        "property": "StartMile, EndMile",
        "condition": "StartMile > EndMile",
        "message": "Start mile must not be greater than end mile.",
        "severity": "Error",
        "context": "When both StartMile and EndMile are provided"
      }
    ]
  },
  "methods": {
    "factory": [
      {
        "name": "NewRiverArea",
        "returnType": "RiverArea",
        "parameters": [],
        "scope": "Public Shared",
        "description": "Creates a new RiverArea instance with default values"
      },
      {
        "name": "NewRiverAreaAsChild",
        "returnType": "RiverArea",
        "parameters": [],
        "scope": "Friend Shared",
        "description": "Creates a new RiverArea instance as a child object"
      },
      {
        "name": "GetRiverArea",
        "returnType": "RiverArea",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32"
          }
        ],
        "scope": "Public Shared",
        "description": "Loads an existing RiverArea by ID"
      },
      {
        "name": "GetRiverAreaChild",
        "returnType": "RiverArea",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32"
          }
        ],
        "scope": "Friend Shared",
        "description": "Loads an existing RiverArea by ID as a child object"
      },
      {
        "name": "GetRiverAreaChild",
        "returnType": "RiverArea",
        "parameters": [
          {
            "name": "dr",
            "type": "SafeDataReader"
          }
        ],
        "scope": "Friend Shared",
        "description": "Loads an existing RiverArea from a DataReader as a child object"
      }
    ],
    "crud": [
      {
        "name": "Save",
        "returnType": "BusinessBase",
        "description": "Saves the RiverArea and marks RiverAreaList and RiverAreaSegmentList caches as dirty",
        "scope": "Public Override"
      },
      {
        "name": "SaveNoRefresh",
        "returnType": "void",
        "description": "Saves the RiverArea without refresh and marks RiverAreaList and RiverAreaSegmentList caches as dirty",
        "scope": "Public Override"
      },
      {
        "name": "DeleteRiverArea",
        "returnType": "void",
        "parameters": [
          {
            "name": "ID",
            "type": "Int32"
          }
        ],
        "scope": "Public Shared Shadows",
        "description": "Deletes a RiverArea by ID and marks RiverAreaList and RiverAreaSegmentList caches as dirty"
      }
    ],
    "businessLogic": [
      {
        "name": "CheckOverlappingPricingZones",
        "returnType": "void",
        "scope": "Private",
        "description": "Compares the Start Mile and End Mile of each river segment against any other pricing zone with matching river segments to determine if there is an overlap",
        "implementation": "Only applies when IsPriceZone is true. Queries RiverAreaPriceZoneSearch to find other pricing zones with matching rivers, then uses HasOverlappingMiles to check for mile range overlaps"
      },
      {
        "name": "HasOverlappingMiles",
        "returnType": "Boolean",
        "parameters": [
          {
            "name": "myStartMile",
            "type": "Decimal"
          },
          {
            "name": "myEndMile",
            "type": "Decimal"
          },
          {
            "name": "otherStartMile",
            "type": "Decimal"
          },
          {
            "name": "otherEndMile",
            "type": "Decimal"
          }
        ],
        "scope": "Private",
        "description": "Determines if two mile ranges overlap",
        "logic": "Returns false if (myEndMile <= otherStartMile) OR (myStartMile >= otherEndMile), otherwise returns true"
      }
    ],
    "initialization": [
      {
        "name": "Initialize",
        "returnType": "void",
        "scope": "Public Override",
        "description": "Initializes the RiverArea with default values and friendly display names for business rules",
        "defaults": [
          {
            "property": "IsActive",
            "value": "true"
          },
          {
            "property": "p_dispIsPriceZone",
            "value": "\"Pricing zone\""
          },
          {
            "property": "p_dispIsPortalArea",
            "value": "\"Portal area\""
          },
          {
            "property": "p_dispIsHighWaterArea",
            "value": "\"High water area\""
          },
          {
            "property": "p_dispCustomerID",
            "value": "\"High water customer\""
          }
        ]
      },
      {
        "name": "CheckBusinessRules",
        "returnType": "void",
        "parameters": [
          {
            "name": "PropertyName",
            "type": "String"
          }
        ],
        "scope": "Public Override",
        "description": "Validates business rules for the specified property or all properties if PropertyName is empty"
      }
    ],
    "validation": [
      {
        "name": "IsValid",
        "returnType": "Boolean",
        "scope": "Public Override ReadOnly Property",
        "description": "Returns true if the RiverArea and all its child RiverAreaSegments are valid. Triggers CheckOverlappingPricingZones before validation."
      }
    ]
  },
  "relationships": [
    {
      "property": "RiverAreaSegments",
      "relatedEntity": "RiverAreaSegment",
      "type": "OneToMany",
      "cascadeDelete": true,
      "lazyLoading": true,
      "description": "Collection of river segments that define the geographic boundaries of this river area"
    }
  ],
  "initialization": {
    "method": "Initialize",
    "defaults": [
      {
        "property": "RiverAreaID",
        "value": "0"
      },
      {
        "property": "Name",
        "value": "String.Empty"
      },
      {
        "property": "IsActive",
        "value": "true"
      },
      {
        "property": "IsPriceZone",
        "value": "false"
      },
      {
        "property": "IsPortalArea",
        "value": "false"
      },
      {
        "property": "IsHighWaterArea",
        "value": "false"
      },
      {
        "property": "CustomerID",
        "value": "String.Empty"
      },
      {
        "property": "IsFuelTaxArea",
        "value": "false"
      },
      {
        "property": "IsLiquidRateArea",
        "value": "false"
      },
      {
        "property": "RiverAreaSegments",
        "value": "NewRiverAreaSegmentsAsChild"
      }
    ]
  },
  "dataAccess": {
    "storedProcedures": {
      "fetch": "RiverAreaSelect",
      "fetchAll": "RiverAreasSelect",
      "insert": "RiverAreaInsert",
      "update": "RiverAreaUpdate",
      "delete": "RiverAreaDelete"
    },
    "parameters": {
      "primaryKey": "@RiverAreaID",
      "insert": [
        "@Name",
        "@IsActive",
        "@IsPriceZone",
        "@IsPortalArea",
        "@IsHighWaterArea",
        "@CustomerID",
        "@IsFuelTaxArea",
        "@IsLiquidRateArea"
      ],
      "update": [
        "@RiverAreaID",
        "@Name",
        "@IsActive",
        "@IsPriceZone",
        "@IsPortalArea",
        "@IsHighWaterArea",
        "@CustomerID",
        "@IsFuelTaxArea",
        "@IsLiquidRateArea"
      ]
    }
  },
  "cacheManagement": {
    "description": "RiverArea manages cache invalidation for RiverAreaList and RiverAreaSegmentList",
    "invalidatedCaches": [
      "RiverAreaList",
      "RiverAreaSegmentList"
    ],
    "triggeredBy": [
      "Save",
      "SaveNoRefresh",
      "DeleteRiverArea"
    ]
  },
  "auditFields": {
    "enabled": true,
    "fields": [
      "RiverAreaID",
      "Name",
      "IsActive",
      "IsPriceZone",
      "IsPortalArea",
      "IsHighWaterArea",
      "CustomerID",
      "IsFuelTaxArea",
      "IsLiquidRateArea"
    ],
    "description": "Field-level auditing tracks changes to specified fields with original and new values"
  },
  "specialNotes": [
    "The CustomerID property is stored as a string internally but represents an Int32 value. It uses SetInt32Prop for property setting but GetStringValue for loading from database.",
    "The form automatically clears the CustomerID field when the user clicks Submit if IsHighWaterArea is not checked.",
    "The OverlappingPricingZones rule is only checked when IsValid property is accessed, not automatically on property changes.",
    "RiverAreaSegment uses formatted mile display with two decimal places via FormattedMile method.",
    "The mutually exclusive area types (IsPriceZone, IsPortalArea, IsHighWaterArea) rule prevents more than one from being true simultaneously."
  ]
}
